#include <string>

std::string vertexShaderSource =
"#version 330 core\n"
"\n"
"layout(location = 0) in vec3 in_position;\n"
"layout(location = 1) in vec3 in_normal;\n"
"layout(location = 2) in vec2 in_uv;\n"
"layout(location = 3) in vec3 in_normal_tan;\n"
"layout(location = 4) in vec3 in_normal_bitan;\n"
"uniform vec3 u_translate_pos;\n"
"uniform vec3 u_translate_scale;\n"
"uniform vec4 u_translate_rot_quat;\n"
"uniform mat4 u_projection;\n"
"uniform mat4 u_look_at;\n"
"out vec4 fragment_norm;\n"
"out vec4 fragment_pos;\n"
"out vec2 fragment_uv;\n"
"out mat4 m_normal_translate;\n"
"out mat4 m_norm_tbn;\n"
"out vec3 T;\n"
"out vec3 B;\n"
"out vec3 N;\n"
"\n"
"void main()\n"
"{\n"
"  vec4 position = vec4(in_position, 1.0);\n"
"  vec4 normal = vec4(in_normal, 0.0);\n"
"  mat4 m_transform_pos = mat4(1.0);\n"
"  m_transform_pos[3][0] = u_translate_pos.x;\n"
"  m_transform_pos[3][1] = u_translate_pos.y;\n"
"  m_transform_pos[3][2] = u_translate_pos.z;\n"
"\n"
"  mat4 m_transform_scale = mat4(1.0);\n"
"  m_transform_scale[0][0] = u_translate_scale.x;\n"
"  m_transform_scale[1][1] = u_translate_scale.y;\n"
"  m_transform_scale[2][2] = u_translate_scale.z;\n"
"\n"
"  mat4 m_transform_rot = mat4(1.0);\n"
"  float qx = u_translate_rot_quat.x;\n"
"  float qy = u_translate_rot_quat.y;\n"
"  float qz = u_translate_rot_quat.z;\n"
"  float qw = u_translate_rot_quat.w;\n"
"  float n = 1.0f/sqrt(qx*qx+qy*qy+qz*qz+qw*qw);"
"  qx *= n;"
"  qy *= n;"
"  qz *= n;"
"  qw *= n;"
"  m_transform_rot[0][0] = 1.0 - 2.0*qy*qy - 2.0*qz*qz;\n"
"  m_transform_rot[0][1] = 2.0*qx*qy + 2.0*qz*qw;\n"
"  m_transform_rot[0][2] = 2.0*qx*qz - 2.0*qy*qw;\n"
"  m_transform_rot[1][0] = 2.0*qx*qy - 2.0*qz*qw;\n"
"  m_transform_rot[1][1] = 1.0 - 2.0*qx*qx - 2.0*qz*qz;\n"
"  m_transform_rot[1][2] = 2.0*qy*qz + 2.0*qx*qw;\n"
"  m_transform_rot[2][0] = 2.0*qx*qz + 2.0*qy*qw;\n"
"  m_transform_rot[2][1] = 2.0*qy*qz - 2.0*qx*qw;\n"
"  m_transform_rot[2][2] = 1.0 - 2.0*qx*qx - 2.0*qy*qy;\n"
"\n"
"  mat4 m_model = m_transform_pos * m_transform_rot * m_transform_scale;\n"
"\n"
"  gl_Position = u_projection * u_look_at * m_model * position;\n"
"  m_normal_translate = m_transform_rot * m_transform_scale;\n"
"  // /!\\ expensive! better calc this once on CPU and just pass it in.\n"
"  //fragment_norm = transpose(inverse(m_transform_rot * m_transform_scale)) * normal;\n"
"  //fragment_norm = normalize(transpose(inverse(m_transform_rot * m_transform_scale)) * normal);\n"
"  //fragment_norm = normalize(m_normal_translate * normal);\n"
"  fragment_norm = normalize(normal);\n"
"  //fragment_norm = m_transform_rot * m_transform_scale * normal;\n"
"  //fragment_norm = vec4(normalize(mat3(transpose(inverse(m_model))) * vec3(normal)), 0.0);\n"
"  fragment_pos = m_model * position;\n"
"  fragment_uv = in_uv;\n"
"  //vec3 T = normalize(vec3(m_model * vec4(in_normal_tan, 0.0)));\n"
"  //vec3 B = normalize(vec3(m_model * vec4(in_normal_bitan, 0.0)));\n"
"  //vec3 N = normalize(vec3(m_model * vec4(in_normal, 0.0)));\n"
"  //vec3 T = normalize(vec3( vec4(in_normal_tan, 0.0)));\n"
"  //vec3 B = normalize(vec3( vec4(in_normal_bitan, 0.0)));\n"
"  //vec3 N = normalize(vec3( vec4(in_normal, 0.0)));\n"
"  //vec3 T = normalize(in_normal_tan);\n"
"  //vec3 B = normalize(in_normal_bitan);\n"
"  //vec3 N = normalize(in_normal);\n"
"   T = normalize(in_normal_tan);\n"
"   B = normalize(in_normal_bitan);\n"
"   N = normalize(in_normal);\n"
"  //m_norm_tbn = mat4(mat3( in_normal_tan, in_normal_bitan, in_normal ));\n"
"  m_norm_tbn = mat4(mat3( T, B, N ));\n"
"  m_norm_tbn[3][3] = 1.0;\n"
"  //m_norm_tbn = u_look_at * m_model * m_norm_tbn;\n"
"  //m_norm_tbn = m_norm_tbn * u_look_at * m_model;\n"
"  m_norm_tbn = m_model * m_norm_tbn;\n"
"}\n"
;

std::string fragmentShaderSource =
"#version 330 core\n"
"\n"
"layout(location = 0) out vec4 color;\n"
"in vec4 fragment_norm;\n"
"in vec4 fragment_pos;\n"
"in vec2 fragment_uv;\n"
"in mat4 m_normal_translate;\n"
"in mat4 m_norm_tbn;\n"
"uniform vec3 u_eye_pos;\n"
"uniform sampler2D u_tex_color;\n"
"uniform sampler2D u_tex_normal;\n"
"uniform sampler2D u_tex_specular;\n"
"in vec3 T;\n"
"in vec3 B;\n"
"in vec3 N;\n"
"\n"
"void main()\n"
"{\n"
"  //vec4 fragColor = vec4(0.6, 0.2, 0.0, 1.0);\n"
"  vec4 fragColor = texture(u_tex_color, fragment_uv);\n"
"  vec4 specMap = texture(u_tex_specular, fragment_uv);\n"
"  float specMapped = specMap.r * specMap.g * specMap.b;\n"
"  //fragColor = texture(u_tex_normal, fragment_uv);\n"
"\n"
"  // lighting calculation\n"
"  vec4 light_ambient = vec4(0.2, 0.2, 0.2, 1.0);\n"
"  vec4 light_pos = vec4(0.75, 0.25, 1.0, 1.0);\n"
"  vec4 light_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"  float light_spec_strength = 0.5;\n"
"\n"
"  vec4 norm_mapped = texture(u_tex_normal, fragment_uv) * 2.0 - 1.0;\n"
"  norm_mapped.w = 0.0;\n" // m_norm_tbn
"  //norm_mapped.r = norm_mapped.r * 2.0 - 1.0;\n"
"  //norm_mapped.g = norm_mapped.g * 2.0 - 1.0;\n"
"  //norm_mapped.b = norm_mapped.b * 2.0 - 1.0;\n"
"  //vec4 light_frag_norm = normalize(fragment_norm);\n"
"  vec4 light_frag_norm = normalize(m_norm_tbn * norm_mapped);\n"
"  //vec4 light_frag_norm = vec4(normalize(mat3(m_norm_tbn) * vec3(norm_mapped)), 0.0);\n"
"  //vec4 light_frag_norm = normalize(m_norm_tbn * vec4(0.0, 0.0, 1.0, 0.0));\n"
"  //vec4 light_frag_norm = vec4(normalize(mat3(m_norm_tbn) * vec3(norm_mapped)), 0.0);\n"
"  // // light_frag_norm = normalize(m_normal_translate * light_frag_norm);\n"
"  vec4 light_dir = vec4(normalize(vec3(light_pos.xyz) - vec3(fragment_pos.xyz)), 0.0);\n"
"\n"
"  // - specular lighting\n"
"  vec4 view_dir = normalize(vec4(u_eye_pos, 1.0) - fragment_pos);\n"
"  vec4 reflect_dir = reflect(-light_dir, light_frag_norm);\n"
"  float spec = pow(max(dot(vec3(view_dir.xyz), vec3(reflect_dir.xyz)), 0.0), 512);\n"
"  vec4 light_spec = light_spec_strength * spec * light_color;\n"
"  light_spec = light_spec * specMapped;\n"
"\n"
"  // - diffuse lighting\n"
"  float diff = max(dot(light_frag_norm, light_dir), 0.0);\n"
"  vec4 light_diffuse = diff * light_color;\n"
"\n"
"  //vec4 blah = (light_frag_norm + 1.0) / 2.0;\n"
"  vec4 blah = (vec4(T, 1.0) + 1.0) / 2.0;\n"
"  blah.w = 1.0;\n"
"  //fragColor = blah; //fragColor * (light_ambient + light_diffuse + light_spec);\n"
"  fragColor = fragColor * (light_ambient + light_diffuse + light_spec);\n"
"  //fragColor = fragColor * (light_diffuse + light_spec);\n"
"  //fragColor.r = max( fragColor.r, light_ambient.r );\n"
"  //fragColor.g = max( fragColor.g, light_ambient.g );\n"
"  //fragColor.b = max( fragColor.b, light_ambient.b );\n"
"\n"
"  if( gl_FrontFacing )\n"
"  {\n"
"    color = fragColor;\n"
"  } else {\n"
"    color = vec4(0.0, 0.0, 0.5, 1.0);\n"
"  }\n"
"}\n"
;
